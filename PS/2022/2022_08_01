<주간 복습>

#dp -> max값의 활용에 대해서 잘 생각

결국 풀어져서 반복 사용되는 부분들을 dp 배열을 이용해서 축약시켜 만든 코드

#2156

a = [6, 10, 13, 9, 8, 1]
dp = [0]*len(a)
dp[0] = a[0]
dp[1] = a[0] + a[1]

for i in range(2, len(a)):
    for j in range(i):
        dp[i] = max(dp[1]+a[j-2]+a[j-1], dp[0]+a[j-2]+a[j-1], a[j-2] + a[j-1])
        
dp[2] = max(dp[1], a[1]+a[2],dp[0]+a[3])

#11053 -> 아깝게 못풀음 도중에 흐름을 잃음

n = int(input())
a = list(map(int,input().split()))

dp = [1] * len(a)
for i in range(1, len(a)):
    for j in range(i):
        if a[i] > a[j]:
        조건문까진 생각해냈으나 어떻게 추려내야할지 모르겠었음
        -> max 메소드 활용해서 추출함 -> i, j 각자 증가로 만들어서 j가 향한 배열의 +1 하면 자동으로 올라감
        
#9465

c = [50, 10, 100, 20, 40]
d = [30, 50, 70, 10, 60]

dp[0] = max(c[0], d[0])
dp[1] = max(c[0]+ d[1], c[1]+d[0])
dp[2] = dp[0] + max(c[2]+d[1], d[2])
dp[3] = dp[1] + max(c[2]+d[3], c[3]+d[2])
dp[4] = max(dp[2] + c[4] + d[3], dp[2] + d[4])


dp 배열 정리를 일일히 짜보았다. 코드는 지저분해 보일수 있지만 일단 현재 내 수준을 이렇다 이걸 좀더 축약해보는 연습까지 해보자.


        
        
